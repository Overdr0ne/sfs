#+TITLE: SFS (Search File System)
#+OPTIONS: toc:2

* Introduction
SFS is a collection of inter-operating tools to make accessing and organizing your data faster and more ergonomic.

[[./sfs-demo.gif]]

* Installation
Install the python dependencies:
#+begin_src
sudo pip3 install dbus-python PyGObject
#+end_src
You will also need to install Recoll, go [[https://www.lesbonscomptes.com/recoll/download.html][here]].
* sfs-recoll
sfs-recoll is an interface to Recoll for Emacs. Recoll search queries are forwarded to a search service, and the results are used to populate a dired buffer.

[[./sfs-demo.gif]]

* Indexing
Start by configuring what and how you want to index in your recoll.conf, or for convenience:
#+begin_src
sfs-index-config
#+end_src
Then, run the indexer, using the *recollindex* command, or within emacs:
#+begin_src
sfs-index-build
#+end_src
You may run that [[https://www.lesbonscomptes.com/recoll/usermanual/webhelp/docs/RCL.INDEXING.PERIODIC.html][periodically]], or have recoll index in [[https://www.lesbonscomptes.com/recoll/usermanual/webhelp/docs/RCL.INDEXING.MONITOR.html][real time ]]with the command *recollindex -m*. I just put that command in my .xinitrc, but you could also set it up as a systemd service or something.
Before you can search, you must index your filesystem with the program *recollindex*. There are a number of options here, but basically you can do this [[https://www.lesbonscomptes.com/recoll/usermanual/webhelp/docs/RCL.INDEXING.PERIODIC.html][periodically]], or in [[https://www.lesbonscomptes.com/recoll/usermanual/webhelp/docs/RCL.INDEXING.MONITOR.html][real time]], updating the index every time a file is modified!
* Searching
The way this works, search queries are forwarded to the python search service that's started when the package loads, and the results are used to populate a dired buffer.
Queries may be entered in the minibuffer with:
#+begin_src
sfs-recoll
#+end_src
Or, in the full query editor with:
#+begin_src
sfs-recollect
#+end_src
The editor allows provides a number of keybindings to quickly insert any of Recolls metadata tags, as well as save your queries to recollections described in the next section. When you save a query, it can inserted into the recollections hierarchy using '.' just like you would a file.at.some.path.

Recoll search queries are fully documented [[https://www.lesbonscomptes.com/recoll/usermanual/webhelp/docs/RCL.SEARCH.LANG.html][here]]. The syntax is very similar to an internet search engine.

You can search for keywords individually:
#+begin_src
Query: keywords to look for in the index
#+end_src
Or clustered phrases:
#+begin_src
Query: "keywords to look" for in "the index"
#+end_src
Recoll also recognizes certain field names:
#+begin_src
Query: filename:test OR filename:bla ext:c dir:home -dir:bin size<10000 date:2001-03-01/2021-05-01
#+end_src
So this gives me files with test or bla in the filename, .c files, home somewhere in the path, bin nowhere in the path, files less than 10000 bytes, and dated between 2001-03-01 and 2021-05-01.

The full list of field names for convenience:
- *title*, *subject* or *caption* are synonyms which specify data to be searched for in the document title or subject.
- *author* or *from* for searching the documents originators.
- *recipient* or *to* for searching the documents recipients.
- *keyword* for searching the document-specified keywords (few documents actually have any).
- *filename* for the document's file name.
- *containerfilename*. This is set for all documents, both top-level and contained sub-documents, and is always the name of the filesystem directory entry which contains the data.
- *ext* specifies the file name extension (Ex: ext:html)
- *dir* for filtering the results on file location
- *size* for filtering the results on file size.
- *date* for searching or filtering on dates.
- *mime* or *format* for specifying the MIME type.
- *type* or *rclcat* for specifying the category (as in text/media/presentation/etc.)

* Recollections
So this is by far my favorite part of SFS, and where the magic really starts to happen. Recollections are basically just saved queries. They can also be thought of as file directories in that they can composed into hierarchies, but unlike directories they are defined by the semantics of the query language. See what I mean with:
#+begin_src
sfs-recollections
#+end_src
You can then execute the query at a point with <return>, much like you would enter a directory in dired or something. So when I make a recollection called images, I can actually make sure it contains all and only image files, which is usually what people want when they define their file hierarchies. The hierarchy here is actually just an alternative representation of queries themselves, in other words, it is the AST representation of recoll search queries. And you can absolutely just write in a query in its hierarchical form and execute it, like so:
#+begin_src
\* OR
\** AND
\*** ext:c
\*** filename:test
\*** size:<1M
\** AND
\*** ext:js
\*** filename:bla
\*** date:2019/
\** inline test query type:text
#+end_src
I haven't quite covered the entirety of the query language here, specifically the ',' and '/' operators are not covered. Queries entered here are also not yet saved between sessions.

* sfs-tags
*unfinished* sfs-tags is a set of utilities for tagging your data, primarily unix files using extended attributes. In a dired directory, tag the file at point with
#+begin_src
sfs-tag-set
#+end_src
and dump the tag info with
#+begin_src
sfs-tag-get
#+end_src

* TODO SFS [1/6]
- [X] Add a fancy start page with lots of suggested tag buttons, search history, help commands, etc. that can be conveniently added and removed and composed, sorta like a root directory, model it a bit like magit with really short keybindings.
  + [X] The recollector is my answer to this
- [ ] parse infixed queries from the recollector into their AST representations such that they can be inserted into the recollections.
- [-] Iterative filtering of results so it feels more like you are navigating your file-system, but non-hierarchically!
  + [-] I think the query system is fast enough that simply not deleting the query after search is good enough, though maybe I could have search easily configured to be performed in a separate window or section of the dired buffer to make it more clearly integrated, and dynamically update results...
- [ ] completion integration for each tag
- [ ] Improve help to make the query language more obvious and intuitive
- [-] Cross-platform...
  + [-] Linux
  + [ ] Mac
  + [ ] Windows
- Bugs...
  + From Recoll: "mime, rclcat, size and date criteria always affect the whole query (they are applied as a final filter), even if set with other terms inside a parenthese. mime (or the equivalent rclcat) is the only field with an OR default. You do need to use OR with ext terms for example." One consequence is you can't OR dates :(
  + The query editor is basically a major mode inside another major mode. Emacs does not natively support multiple major modes in a single buffer, so what I have is a big, ugly hack. You can break out of editibility by backspacing the first character, then you're stuck in read-only. ugh...
  + Syntax highlighting is very basic, not context aware, and can conflate a date '/' with the or operator
